{"id":"3c729ad6-8ba8-41e9-ad05-4b4779c0a577","zed":"context","version":"0.4.0","text":"```h libhwtrace/hwtrace/include/AppleHWTrace.h\n//===-- AppleHWTrace.h --------------------------------------------*- C -*-===//\n//\n// CONFIDENTIAL - Copyright Apple Inc.\n//\n//===----------------------------------------------------------------------===//\n\n#pragma once\n\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <uuid/uuid.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n// Note: The python bindings to libhwtrace are generated by a script that\n// parses this header. Don't reformat this file: doing so can break the script.\n// clang-format off\n\n/**\n * The following API is built around a cursor abstraction which wraps a logical stream of instructions.  API is in place to navigate\n * the topology of a trace and construct and move cursors to point to interesting points in time.\n *\n * This API is considered to be stable as we may be making minor style and calling convention changes to select functions.\n *\n * API that deals with live systems (exploring the current machine's topology or collecting a trace) is not supported in the\n * Devtools build (gated by HWTRACE_DEVTOOLS).\n */\n\n/**\n * @brief HWTRACE_API_VERSION is incremented each time an addition, deletion, or edit is made to the new API.\n *\n * This allows adopters a way to conditionally-compile code in the middle of a release (per rdar://118243677).\n * Eventually, this may be supplemented or replaced with availability annotations (rdar://102053908).\n *\n * note: Implementors should leave a short, dated note explaining API changes in the list below.\n *\n * Versions:\n *   1. Initial API surface (Nov 10 2023)\n *   2. Fast pause/attach API (Jan 08 2024)\n *   3. Throttling API (Jan 09 2024)\n *   4. hwtrace_trace_init_from_ktrace (Jan 11 2024)\n *   5. Removed: hwtrace_trace_init_from_ktrace, Added: hwtrace_recording_init_from_ktrace (Jan 18 2024)\n *   6. Added: hwtrace_system_did_wrap (Feb 13 2024)\n *   7. Added: hwtrace_recording_save_options_t, hwtrace_recording_save_options_set_ktrace_file, hwtrace_recording_save_options_set_path, hwtrace_recording_save_options_set_port_mode (Jul 25 2024)\n *   8. Added: hwtrace_recording_save_options_set_decode_trace (Jul 30 2024)\n *   9. Added: hwtrace_live_recording_resume (Oct 16 2024)\n *   10. Added: hwtrace_cluster_{id,type} (Oct 23 2024)\n *   11. Added: hwtrace_live_recording_system_options_set_rate_limit (Oct 29 2024)\n *   12. Added: hwtrace_recording_{start,stop}_timestamps (Oct 31 2024)\n *   13. Added: hwtrace_async_task_t, hwtrace_cursor_context (Nov 15 2024)\n *   14. Added: hwtrace_task_name (Nov 19 2024)\n *   15. Added: hwtrace_cursor_copy (Dec 3 2024)\n *   16. Added: hwtrace_live_recording_system_options_set_address_capture (Nov 22 2024)\n *   17. Added: hwtrace_live_recording_traced_bytes (Jan 8 2025)\n *   18. Added: hwtrace_isa_{init,deinit} (Jan 29, 2025)\n *   19. Added: hwtrace_range_terminator_continuation (Feb 03, 2025)\n *   20. Added: hwtrace_system_type_scrt (Feb 6, 2025)\n *   21. Added: hwtrace_version_info and hwtrace_version_compatible_decode_format (Feb 12, 2025)\n */\n#define HWTRACE_API_VERSION 21\n\n#pragma mark - Core Type Definitions\n\ntypedef struct ktrace_file *ktrace_file_t;\ntypedef struct ktrace_session *ktrace_session_t;\n\ntypedef int32_t                      hwtrace_error_t;\ntypedef struct hwtrace_recording    *hwtrace_recording_t;\ntypedef struct hwtrace_trace        *hwtrace_trace_t;\ntypedef struct hwtrace_image        *hwtrace_image_t;\ntypedef struct hwtrace_segment      *hwtrace_segment_t;\ntypedef struct hwtrace_topology     *hwtrace_topology_t;\ntypedef struct hwtrace_system       *hwtrace_system_t;\ntypedef struct hwtrace_cluster      *hwtrace_cluster_t;\ntypedef struct hwtrace_core         *hwtrace_core_t;\ntypedef struct hwtrace_task         *hwtrace_task_t;\ntypedef struct hwtrace_async_task   *hwtrace_async_task_t;\ntypedef struct hwtrace_thread       *hwtrace_thread_t;\ntypedef struct hwtrace_cursor       *hwtrace_cursor_t;\ntypedef struct hwtrace_range        *hwtrace_range_t;\ntypedef struct hwtrace_recording_save_options *hwtrace_recording_save_options_t;\n\n/**\n * @brief Represents a type of operating system.\n */\ntypedef enum {\n  hwtrace_system_type_xnu = 0,\n  hwtrace_system_type_rtkit,\n  hwtrace_system_type_sep,\n  hwtrace_system_type_scrt,\n} hwtrace_system_type_t;\n\n/**\n * @brief Kind of throttling action.\n */\ntypedef enum {\n  hwtrace_throttle_action_pause = 0,\n  hwtrace_throttle_action_resume,\n} hwtrace_throttle_action_t;\n\ntypedef void (*hwtrace_throttle_action_callback_t)(hwtrace_throttle_action_t, void *);\n\n#pragma mark - Versioning & Compatibility\n\n/**\n * @brief Get a string describing the version details from this copy of\n * libhwtrace. Caller has ownership of the string.\n *\n * @return const char * - The caller is responsible for freeing this string\n * with a call to free()\n */\nconst char *hwtrace_version_info(void);\n\n/**\n * @brief Check if decode results from a copy of libhwtrace described by the\n * producer version string can be opened by this copy of libhwtrace.\n *\n * @param producer_ver_info - A version string produced by a call to\n * hwtrace_version_info() from the producer copy of libhwtrace. Ownership is\n * retained by the caller.\n *\n * @param guidance_on_failure [inout] - A nullable pointer to a string; if there\n * is a compatibility issue, a detailed error description as well as guidance for\n * the user is copied into a string and stored into this pointer. The caller\n * has ownership of this string and is responsible for freeing it with a call\n * to free().\n *\n * @return bool - Whether the producer's decode results can be loaded\n */\nbool hwtrace_version_compatible_decode_format(const char *producer_ver_info, const char **guidance_on_failure);\n\n#pragma mark - Logging\n\ntypedef enum {\n  hwtrace_log_level_default = 0,\n  hwtrace_log_level_info,\n  hwtrace_log_level_debug,\n  hwtrace_log_level_error,\n} hwtrace_log_level_t;\n\ntypedef void (*hwtrace_log_callback_t)(hwtrace_log_level_t, const char*);\n\n/**\n * @brief Register a log callback to handle\n *\n * @param callback\n * @return hwtrace_error_t\n */\nhwtrace_error_t hwtrace_set_logger(hwtrace_log_callback_t callback);\n\n#pragma mark - Live Topology\n\n#ifndef HWTRACE_DEVTOOLS\n\ntypedef struct hwtrace_live_topology  *hwtrace_live_topology_t;\ntypedef struct hwtrace_live_system    *hwtrace_live_system_t;\ntypedef struct hwtrace_live_recording_options *hwtrace_live_recording_options_t;\ntypedef struct hwtrace_live_recording_system_options *hwtrace_live_recording_system_options_t;\ntypedef struct hwtrace_live_recording_postprocess_options *hwtrace_live_recording_postprocess_options_t;\ntypedef struct hwtrace_live_recording *hwtrace_live_recording_t;\ntypedef struct hwtrace_live_recording_session *hwtrace_live_recording_session_t;\n\n/**\n * @brief Get the topology for the device.\n *\n * @return hwtrace_live_topology_t\n */\nhwtrace_live_topology_t hwtrace_live_topology();\n\n/**\n * @brief Get the list of systems associated with a live_topology.\n *\n * A recording may consist of any number of systems across multiple operating systems,\n * including XNU, RTKit, cL4.\n *\n * @param topology - the topology\n * @param[in, out] systems - pointer to the array of live systems\n * @param[in, out] len - pointer to the number of elements in \\p systems\n */\nvoid hwtrace_live_topology_systems(hwtrace_live_topology_t topology, hwtrace_live_system_t **systems, size_t* len);\n\n/**\n * @brief Returns the name of a live system.\n *\n * @return system name\n */\nconst char *hwtrace_live_system_name(hwtrace_live_system_t system);\n\n/**\n * @brief Fundamental capabilities that may be supported/unsupported for specific systems on the current SOC.\n *\n * This is generally useful for constructing well formed live_recording_system_options_t.\n */\ntypedef enum {\n  hwtrace_live_system_capability_driver,\n  hwtrace_live_system_capability_driver_development_trace,\n  hwtrace_live_system_capability_driver_production_trace,\n  hwtrace_live_system_capability_trace_mode_filesystem,\n  hwtrace_live_system_capability_pio,\n  hwtrace_live_system_capability_counter_dump,\n} hwtrace_live_system_capability_t;\n\n/**\n * @brief Check if the specified capability is supported for the specified system.\n *\n * @param system - the live system\n * @param capability - the capability to check\n * @return true if the capability is supported\n * @return false otherwise\n */\nbool hwtrace_live_system_has_capability(hwtrace_live_system_t system, hwtrace_live_system_capability_t capability);\n\n#pragma mark - Live Recording Options\n\n/**\n * @brief Create mutable live recording options.\n *\n * @return hwtrace_live_recording_options_t\n */\nhwtrace_live_recording_options_t hwtrace_live_recording_options_init(void);\nvoid hwtrace_live_recording_options_deinit(hwtrace_live_recording_options_t options);\n\n/**\n * @brief Describes how ktrace sessions should be created or consumed when used to\n * discover information about traced processes.\n */\ntypedef enum {\n  /// Standalone session, ktrace will not be used during recording.\n  hwtrace_live_recording_option_session_policy_standalone = 0,\n\n  /// Default\n  /// Create a session, libhwtrace will manage the session lifecycle.\n  hwtrace_live_recording_option_session_policy_create_session,\n\n  /// Use an existing session, libhwtrace will not manage the session lifecycle\n  /// TODO: Consider if standalone can replace this entirely.\n  hwtrace_live_recording_option_session_policy_existing_session,\n} hwtrace_live_recording_option_session_policy_t;\n\n/**\n * @brief Specify recording session policy.\n *\n * Most use cases should not customize the session policy.  The session policy should be modified if you either\n * don't want to use ktrace or have a sideband ktrace session that can be used instead of the system session.\n *\n * @param options - the options to mutate\n * @param policy - the session policy to select\n */\nvoid hwtrace_live_recording_options_set_session_policy(hwtrace_live_recording_options_t options, hwtrace_live_recording_option_session_policy_t policy);\n\n/**\n * @brief Specify if a recording should run in the background.\n *\n * This will prevent libhwtrace from mapping memory until the trace is ready to be saved.\n *\n * @param options - the options to mutate\n * @param enabled - background mode enabled or not\n */\nvoid hwtrace_live_recording_options_set_background(hwtrace_live_recording_options_t options, bool enabled);\n\n/**\n * @brief Specify a path to an image that may not be otherwise discoverable.\n *\n * Overspecifying images that are not mapped in a target process will cause recordings to fail.\n *\n * @param options - the options to mutate\n * @param path - the macho path\n */\nvoid hwtrace_live_recording_options_set_image_override(hwtrace_live_recording_options_t options, const char *path);\n\n/**\n * @brief Specify a system on the current SOC to be recorded.\n *\n * @param options - the options to mutate\n * @param system - the system to trace\n * @return hwtrace_live_recording_system_options_t\n */\nhwtrace_live_recording_system_options_t hwtrace_live_recording_options_add_system(hwtrace_live_recording_options_t options, hwtrace_live_system_t system);\n\n/**\n * @brief Describes the mode for which to configure tracing in for a particular system.\n */\ntypedef enum {\n  // Default.\n  // Trace until the buffer has filled up, no data will be overwritten.\n  hwtrace_live_recording_system_option_trace_mode_oneshot = 0,\n\n  // Trace continuously overwriting older data.\n  hwtrace_live_recording_system_option_trace_mode_ringbuffer,\n\n  // Trace to the filesystem, data may be dropped if NAND cannot keep up with incoming data.\n  hwtrace_live_recording_system_option_trace_mode_filesystem,\n\n  // Virtual ringbuffer where chunks are persisted to the filesystem.\n  // As incoming chunks are processed, older chunks may be overwritten to make space.\n  // Data may be dropped if NAND cannot keep up with incoming data.\n  hwtrace_live_recording_system_option_trace_mode_virtual_ringbuffer_filesystem,\n\n  // Virtual ringbuffer where chunks are persisted in memory.\n  // As incoming chunks are processed, older chunks may be overwritten to make space.\n  // Data may be dropped if NAND cannot keep up with incoming data.\n  hwtrace_live_recording_system_option_trace_mode_virtual_ringbuffer_memory,\n} hwtrace_live_recording_system_option_trace_mode_t;\n\n/**\n * @brief Specify the trace mode for a specific system.\n *\n * @param options - the system options to mutate\n * @param mode - the mode to select\n */\nvoid hwtrace_live_recording_system_options_set_trace_mode(hwtrace_live_recording_system_options_t options, hwtrace_live_recording_system_option_trace_mode_t mode);\n\n/**\n * @brief Specify the size of the virtual trace buffer to use for trace mode virtual_ringbuffer_*\n *\n * @param options - the system options to mutate\n * @param size - the size to select (in bytes)\n */\nvoid hwtrace_live_recording_system_options_set_virtual_ringbuffer_size(hwtrace_live_recording_system_options_t options, uint64_t size);\n\n/**\n * @brief Specify if tracing should use the driver or local PIOs.\n *\n * @param options - the system options to mutate\n * @param enabled - driver enabled or not\n */\nvoid hwtrace_live_recording_system_options_set_driver(hwtrace_live_recording_system_options_t options, bool enabled);\n\n/**\n * @brief Specify if tracing should use production trace.\n *\n * @param options - the system options to mutate\n * @param enabled - production trace enabled or not\n */\nvoid hwtrace_live_recording_system_options_set_production(hwtrace_live_recording_system_options_t options, bool enabled);\n\n/**\n * @brief Types of context filtering that can be configured for a system.\n */\ntypedef enum {\n  // Default.\n  // No filtering in place, all contexts will be traced.\n  hwtrace_live_recording_system_option_context_target_unfiltered = 0,\n\n  // Filter the trace based on specified contexts.\n  hwtrace_live_recording_system_option_context_target_filtered,\n\n  // Intentionally omitting shared contexts from API for now.\n} hwtrace_live_recording_system_option_context_target_t;\n\n/**\n * @brief Specify the context filtering for a system.\n *\n * @param options - the system options to mutate\n * @param target - the context target to select\n */\nvoid hwtrace_live_recording_system_options_set_context_target(hwtrace_live_recording_system_options_t options, hwtrace_live_recording_system_option_context_target_t target);\n\n/**\n * @brief Specify a context to filter on for a system.\n *\n * Calling this function multiple times will append to the list of filtered context targets.\n *\n * @param options - the system options to mutate\n * @param pid - the process id to filter on\n */\nvoid hwtrace_live_recording_system_options_add_context_target_filtered(hwtrace_live_recording_system_options_t options, uint64_t pid);\n\n/**\n * @brief Levels of execution that can be traced.\n */\ntypedef enum {\n  // Default.\n  // Trace exception levels > EL0.\n  hwtrace_live_recording_system_option_exception_level_target_kernel = 0,\n\n  // Trace exception levels >= EL0.\n  hwtrace_live_recording_system_option_exception_level_target_userspace,\n\n  // Trace exception level == EL0.\n  hwtrace_live_recording_system_option_exception_level_target_userspace_only,\n} hwtrace_live_recording_system_option_exception_level_target_t;\n\n/**\n * @brief Specify the exception levels to trace for a system.\n *\n * @param options - the system options to mutate\n * @param target - the exception level target to select\n */\nvoid hwtrace_live_recording_system_options_set_exception_level_target(hwtrace_live_recording_system_options_t options, hwtrace_live_recording_system_option_exception_level_target_t target);\n\n/**\n * @brief Specify whether throttling is enabled. Throttling suspends/resumes the\n * task being traced to prevent trace packet loss. It requires the driver and streaming to be enabled\n * (see hwtrace_live_recording_system_options_set_driver).\n *\n * @param enabled - true if throttling is requested\n * @param callback - function pointer to be called on throttle actions, or NULL\n * @param callback_arg - arbitrary pointer-sized argument to be forwarded to callback\n */\nvoid hwtrace_live_recording_system_options_set_throttling(hwtrace_live_recording_system_options_t options, bool enabled, hwtrace_throttle_action_callback_t callback, void *callback_arg);\n\n/**\n * @brief Specify a data rate limit. If trace data is generated faster than this limit, I/O threads\n * will sleep \"just the right amount\" such that the average I/O rate eventually reaches the specified limit.\n * This causes chunks of trace data to be discarded, due to I/O threads being asleep and thus unavailable to\n * write out freshly-generated trace packets. Rate limiting is only compatible with\n * \\ref hwtrace_live_system_capability_trace_mode_filesystem.\n *\n * The default is that there is no data rate limit.\n *\n * @param limit - a data rate limit expressed in units of MB/s (megabytes per second)\n */\nvoid hwtrace_live_recording_system_options_set_rate_limit(hwtrace_live_recording_system_options_t options, uint32_t limit);\n\n/**\n * @brief Specify whether counter dump is enabled.\n *\n * @param enabled - true if counter dump is requested\n */\nvoid hwtrace_live_recording_system_options_set_counter_dump(hwtrace_live_recording_system_options_t options, bool enabled);\n\n/**\n * @brief Specify if tracing should capture load/store addresses.\n *\n * @param options - the system options to mutate\n * @param enabled - ld/st trace enabled or not\n */\nvoid hwtrace_live_recording_system_options_set_address_capture(hwtrace_live_recording_system_options_t options, bool enabled);\n\n#pragma mark - Live Recording\n\n/**\n * @brief Create options for post-processing a live recording.\n *\n * @return hwtrace_live_recording_postprocess_options_t\n */\nhwtrace_live_recording_postprocess_options_t hwtrace_live_recording_postprocess_options_init(void);\nvoid hwtrace_live_recording_postprocess_options_deinit(hwtrace_live_recording_postprocess_options_t options);\n\n/**\n * @brief Specify a ktrace session to use for post-processing.\n *\n * @param options - the options to mutate\n * @param session - the session used\n */\nvoid hwtrace_live_recording_postprocess_options_set_ktrace_session(hwtrace_live_recording_postprocess_options_t options, ktrace_session_t session);\n\n/**\n * @brief Initialize a live recording with the specified options\n *\n * @param options - the options to apply to the recording\n * @param out - hwtrace_live_recording_t\n * @return hwtrace_error_t\n */\nhwtrace_error_t hwtrace_live_recording_init_with_options(hwtrace_live_recording_options_t options, hwtrace_live_recording_t *out);\n\n/**\n * @brief Initialize a live recording from an existing session.\n *\n * @param session - the session to attach to\n * @param out - hwtrace_live_recording_t\n * @return hwtrace_error_t\n */\nhwtrace_error_t hwtrace_live_recording_init_from_session(hwtrace_live_recording_session_t session, hwtrace_live_recording_t *out);\nvoid hwtrace_live_recording_deinit(hwtrace_live_recording_t recording);\n\n/**\n * @brief Initialize a live recording session from a previously serialized session.\n *\n * @param serialized - the previously serialized session\n * @param out - hwtrace_live_recording_session_t\n * @return hwtrace_error_t\n */\nhwtrace_error_t hwtrace_live_recording_session_init(const char* serialized, hwtrace_live_recording_session_t *out);\nvoid hwtrace_live_recording_session_deinit(hwtrace_live_recording_session_t session);\n\n/**\n * @brief Get the serialized representation of the session.  This can be used to persist a hwtrace_live_recording_session_t\n * to the disk for future access or send to trusted clients participating in a \"distributed\" trace session.\n *\n * @param session - the session to serialize\n * @return const char* - the serialized session\n */\nconst char* hwtrace_live_recording_session_serialize(hwtrace_live_recording_session_t session);\n\n/**\n * @brief Get the unique session identifier.  This can be used by clients to validate that the loaded session uuid matches\n * the client provided uuid.\n *\n * @param session - the session\n * @param uuid - the session uuid\n */\nvoid hwtrace_live_recording_session_uuid(hwtrace_live_recording_session_t session, uuid_t uuid);\n\n/**\n * @brief Start a live recording.\n *\n * @param recording - the live recording to start\n * @param out - hwtrace_live_recording_session_t, useful in cases where sessions might be coordinated between multiple clients\n * @return 0 on success, non-zero if the recording couldn't be started\n */\nhwtrace_error_t hwtrace_live_recording_start(hwtrace_live_recording_t recording, hwtrace_live_recording_session_t *out);\n\n/**\n * @brief Get the number of raw trace bytes captured.\n *\n * @param recording - the live recording to poll\n * @return number of raw trace bytes captured\n */\nuint64_t hwtrace_live_recording_traced_bytes(hwtrace_live_recording_t recording);\n\n/**\n * @brief Pause a live recording.\n *\n * @param recording - the live recording to pause\n * @return 0 on success, non-zero if the recording couldn't be paused\n */\nhwtrace_error_t hwtrace_live_recording_pause(hwtrace_live_recording_t recording);\n\n/**\n * @brief Resume a live recording.\n *\n * @param recording - the live recording to resume\n * @return 0 on success, non-zero if the recording couldn't be resumed\n */\nhwtrace_error_t hwtrace_live_recording_resume(hwtrace_live_recording_t recording);\n\n/**\n * @brief Stop a live recording\n *\n * @param recording - the live recording to stop\n * @return 0 on success, non-zero if the recording couldn't be stopped\n */\nhwtrace_error_t hwtrace_live_recording_stop(hwtrace_live_recording_t recording);\n\n/**\n * @brief Post-process a live recording\n *\n * @param recording - the live recording to post-process\n * @param options - the options with which to post-process\n * @return 0 on success, non-zero if the recording couldn't be post-processed\n */\nhwtrace_error_t hwtrace_live_recording_postprocess(hwtrace_live_recording_t recording, hwtrace_live_recording_postprocess_options_t options);\n\n/**\n * @brief Indicate that postprocessing is complete (typically called from within a ktrace completion handler).\n *\n * discussion: This API signals that the ktrace session completion handler has been invoked, which in turn disallows subsequent trace metadata mutation from within ktrace callbacks. It is safe to call even if there is no ktrace session, or if the session is configured by libhwtrace.\n * It is a mandatory step to promote symmetry with external/existing ktrace sessions, where libhwtrace lacks control over when the session ends. See hwtrace_live_recording_option_session_policy_existing_session.\n *\n * @param recording - the live recording to finish post-processing\n * @return 0 on success, non-zero if ktrace callback processing accumulated any errors\n */\nhwtrace_error_t hwtrace_live_recording_finalize_postprocessing(hwtrace_live_recording_t recording);\n\n/**\n * @brief Initialize a recording from a live recording.\n *\n * @param recording - live recording to convert to a recording\n * @param out - hwtrace_recording_t\n * @return 0 on success, non-zero if the recording could not be initialized\n */\nhwtrace_error_t hwtrace_recording_init_from_live_recording(hwtrace_live_recording_t recording, hwtrace_recording_t *out);\n\n#endif // HWTRACE_DEVTOOLS\n\n#pragma mark - Recording\n\n/**\n * @brief Initialize a recording from a trace directory or traceV3 file.\n *\n * @param directory - path to directory or traceV3 file\n * @param out - hwtrace_recording_t\n * @return 0 on success, non-zero if the recording could not be initialized\n */\nhwtrace_error_t hwtrace_recording_init_from_directory(const char *directory, hwtrace_recording_t *out);\n\n/**\n * @brief Initialize a recording from a ktrace_file_t.\n *\n * Ownership of the ktrace_file_t is retained by the caller. If the ktrace_file_t instance is freed before the hwtrace_recording_t (or derived hwtrace_trace_t) instance is\n * deinitialized, operations on the instances may fail or crash.\n *\n * @param file - ktrace_file_t (caller retains ownership)\n * @param out\n * @return 0 on success, non-zero if the trace could not be initialized\n */\nhwtrace_error_t hwtrace_recording_init_from_ktrace(ktrace_file_t file, hwtrace_recording_t* out);\n\n/**\n * @brief Initialize a recording from a corefile.\n *\n * @param system_type - the type of corefile\n * @param path - path to corefile\n * @param out - hwtrace_recording_t\n * @return 0 on success, non-zero if the recording could not be initialized\n */\nhwtrace_error_t hwtrace_recording_init_from_corefile(hwtrace_system_type_t system_type, const char *path, hwtrace_recording_t *out);\n\n/**\n * @brief Deinit a recording created by a hwtrace_recording_init_*() routine.\n *\n * @param recording - recording to deinitialize.\n */\nvoid hwtrace_recording_deinit(hwtrace_recording_t recording);\n\n/**\n * @brief Save a recording to a path on the filesystem.\n *\n * @param recording - the recording\n * @param path - the filesystem path\n * @return 0 on success, non-zero if the recording couldn't be saved\n */\n__attribute__((deprecated(\"hwtrace_recording_save_to_path copies excessive amounts of data\", \"hwtrace_recording_save is the better replacement\")))\nhwtrace_error_t hwtrace_recording_save_to_path(hwtrace_recording_t recording, const char *path);\n\n/**\n * @brief Save a recording to a traceV3 file.\n *\n * @param recording - the recording\n * @param path - the traceV3 file.\n * @return 0 on success, non-zero if the recording couldn't be saved\n */\n__attribute__((deprecated(\"hwtrace_recording_save_to_ktrace copies excessive amounts of data\", \"hwtrace_recording_save is the better replacement\")))\nhwtrace_error_t hwtrace_recording_save_to_ktrace(hwtrace_recording_t recording, ktrace_file_t file);\n\n/**\n * @brief Initialize save options to apply when saving a trace\n *\n * @return hwtrace_recording_save_options_t\n */\nhwtrace_recording_save_options_t hwtrace_recording_save_options_init();\nvoid hwtrace_recording_save_options_deinit(hwtrace_recording_save_options_t opts);\n\n/**\n * @brief Set a ktrace file to save to.\n *\n * Mutually exclusive with saving to a path.\n */\nvoid hwtrace_recording_save_options_set_ktrace_file(hwtrace_recording_save_options_t opts, ktrace_file_t file);\n\n/**\n * @brief Set a path to save to.\n *\n * Mutually exclusive with saving to a ktrace file.\n */\nvoid hwtrace_recording_save_options_set_path(hwtrace_recording_save_options_t opts, const char *path);\n\ntypedef enum {\n  hwtrace_recording_port_mode_no_op,\n  hwtrace_recording_port_mode_copy_images\n} hwtrace_recording_port_mode_t;\n\n/**\n * @brief Set the port mode.\n *\n * hwtrace_recording_port_mode_no_op leaves all image paths as relative, implying that the trace cannot be copied off-device.\n * hwtrace_recording_port_mode_copy_images copies all potentially-referenced images into the trace, increasing the trace size substantially.\n */\nvoid hwtrace_recording_save_options_set_port_mode(hwtrace_recording_save_options_t opts, hwtrace_recording_port_mode_t mode);\n\n/**\n * @brief Save decoded results into the trace.\n *\n * Saving a trace will opportunistically decode system traces where all images are available. This will save a serialized trace that is\n * trivially decodeable off device without re-decoding the raw traces.\n *\n * @param opts - the recording save options to modify\n * @param enabled - traces will be attempted to be decoded during saving.  Defaults to disabled.\n */\nvoid hwtrace_recording_save_options_set_decode_trace(hwtrace_recording_save_options_t opts, bool enabled);\n\n/**\n * @brief Save a recording per specified options.\n *\n * @param recording - the recording\n * @param opts - the recording save options\n * @return 0 on success, non-zero if the recording couldn't be saved\n */\nhwtrace_error_t hwtrace_recording_save(hwtrace_recording_t recording, hwtrace_recording_save_options_t opts);\n\n#pragma mark - Traces\n\ntypedef struct hwtrace_load_options *hwtrace_load_options_t;\n\n/**\n * @brief Initialize load options to apply when loading a trace\n *\n * @return hwtrace_load_options_t\n */\nhwtrace_load_options_t hwtrace_load_options_init();\nvoid hwtrace_load_options_deinit(hwtrace_load_options_t options);\n\n/**\n * @brief Initialize a trace from a recording.\n *\n * @param recording - recording to use\n * @param options - options to apply while loading\n * @param out\n * @return 0 on success, non-zero if the trace could not be initialized\n */\nhwtrace_error_t hwtrace_trace_init_from_recording(hwtrace_recording_t recording, hwtrace_load_options_t options, hwtrace_trace_t* out);\n\n/**\n * @brief Initialize a trace from a path to a directory or traceV3.\n *\n * @param directory - path to directory or traceV3 file\n * @param options - options to apply while loading\n * @param out\n * @return 0 on success, non-zero if the trace could not be initialized\n */\nhwtrace_error_t hwtrace_trace_init_from_directory(const char *directory, hwtrace_load_options_t options, hwtrace_trace_t* out);\n\n/**\n * @brief Deinit a trace created by a hwtrace_trace_init_*() routine.\n *\n * @param trace - trace to deinitialize.\n */\nvoid hwtrace_trace_deinit(hwtrace_trace_t trace);\n\n#pragma mark - Misc\n\n/**\n * @brief Return the timestamps when tracing was started.\n *\n * @param recording - the recording\n * @param[in, out] timestamps - pointer to the array of timestamps\n * @param[in, out] len - pointer to the number of elements in \\p timestamps\n */\nvoid hwtrace_recording_start_timestamps(hwtrace_recording_t recording, const uint64_t** timestamps, size_t* len);\n\n/**\n * @brief Return the timestamps when tracing was stopped.\n *\n * @param recording - the recording\n * @param[in, out] timestamps - pointer to the array of timestamps\n * @param[in, out] len - pointer to the number of elements in \\p timestamps\n */\nvoid hwtrace_recording_stop_timestamps(hwtrace_recording_t recording, const uint64_t** timestamps, size_t* len);\n\n#pragma mark - Topology\n\n/**\n * @brief Get the topology associated with a recording.\n *\n * @param recording - the recording to use\n * @return hwtrace_topology_t\n */\nhwtrace_topology_t hwtrace_recording_topology(hwtrace_recording_t recording);\n\n/**\n * @brief Get the topology associated with a trace.\n *\n * @param trace - the trace to use\n * @return hwtrace_topology_t\n */\nhwtrace_topology_t hwtrace_trace_topology(hwtrace_trace_t trace);\n\n/**\n * @brief Get the list of systems associated with a topology.\n *\n * A recording may consist of any number of systems across multiple operating systems,\n * including XNU, RTKit, cL4.  The system abstraction allows for efficient grouping of\n * these systems.\n *\n * @param topology - the topology\n * @param[in, out] systems - pointer to the array of systems\n * @param[in, out] len - pointer to the number of elements in \\p systems\n */\nvoid hwtrace_topology_systems(hwtrace_topology_t topology, hwtrace_system_t** systems, size_t* len);\n\n/**\n * @brief Get the name of a system.\n *\n * @param system - the system to get the name of\n * @return const char*\n */\nconst char *hwtrace_system_name(hwtrace_system_t system);\n\n/**\n * @brief Check if any trace data in a system wrapped around.\n *\n * @param system - the system\n * @return bool\n */\nbool hwtrace_system_did_wrap(hwtrace_system_t system);\n\n/**\n * @brief Get the list of clusters associated with a system.\n *\n * A system may consist of any number of clusters, each with different performance\n * characteristics.  The cluster abstraction allows for grouping of logical CPUs by cluster.\n *\n * @param system - the system\n * @param[in, out] clusters - pointer to the array of clusters\n * @param[in, out] len - pointer to the number of elements in \\p clusters\n */\nvoid hwtrace_system_clusters(hwtrace_system_t system, hwtrace_cluster_t** clusters, size_t* len);\n\n/**\n * @brief A type of cluster.\n */\ntypedef enum {\n  hwtrace_cluster_type_e = 0,\n  hwtrace_cluster_type_p,\n  hwtrace_cluster_type_m,\n  hwtrace_cluster_type_asc,\n} hwtrace_cluster_type_t;\n\n/**\n * @brief Get the cluster id associated with a cluster.\n *\n * @param cluster - the cluster\n * @return cluster id\n */\nuint64_t hwtrace_cluster_id(hwtrace_cluster_t cluster);\n\n/**\n * @brief Get the type of the cluster.\n *\n * @param cluster - the cluster\n * @return hwtrace_cluster_type_t\n */\nhwtrace_cluster_type_t hwtrace_cluster_type(hwtrace_cluster_t cluster);\n\n/**\n * @brief Get the list of cores associated with a cluster.\n *\n * @param cluster - the cluster\n * @param cores - pointer to an array of cores\n * @param len - pointer to the number of elements in \\p cores\n */\nvoid hwtrace_cluster_cores(hwtrace_cluster_t cluster, hwtrace_core_t** cores, size_t* len);\n\n/**\n * @brief Get the core id associated with a core.\n *\n * @param core - the core\n * @return core id\n */\nuint64_t hwtrace_core_id(hwtrace_core_t core);\n\n/**\n * @brief Get the list of tasks associated with a system.\n *\n * @param system - the system\n * @param tasks - pointer to an array of tasks\n * @param len - pointer ot the number of elements in \\p tasks\n */\nvoid hwtrace_system_tasks(hwtrace_system_t system, hwtrace_task_t** tasks, size_t* len);\n\n/**\n * @brief Get the list of threads associated with a task.\n *\n * @param task - the task\n * @param threads - pointer to an array of threads\n * @param len - pointer ot the number of elements in \\p threads\n */\nvoid hwtrace_task_threads(hwtrace_task_t task, hwtrace_thread_t** threads, size_t* len);\n\n/**\n * @brief Get the task id associated with a task.\n *\n * @param task - the task\n * @return task id\n */\nuint64_t hwtrace_task_id(hwtrace_task_t task);\n\n/**\n * Get the name of the task.\n *\n * @param task - the task\n * @return task name or null\n */\nconst char *hwtrace_task_name(hwtrace_task_t task);\n\n/**\n * @brief Get the list of async tasks associated with a task.\n *\n * @param task - the task\n * @param async_tasks - pointer to an array of async tasks\n * @param len - pointer ot the number of elements in \\p async_tasks\n */\nvoid hwtrace_task_async_tasks(hwtrace_task_t task, hwtrace_async_task_t** async_tasks, size_t* len);\n\n/**\n * @brief Get the task associated with a thread.\n *\n * @param thread - the thread\n * @return hwtrace_task_t\n */\nhwtrace_task_t hwtrace_thread_task(hwtrace_thread_t thread);\n\n/**\n * @brief Get the thread id associated with a thread.\n *\n * @param thread - the thread\n * @return thread id\n */\nuint64_t hwtrace_thread_id(hwtrace_thread_t thread);\n\n/**\n * @brief Get the async task id associated with an async task.\n *\n * @param async_task - the async task\n * @return async task id\n */\nuint64_t hwtrace_async_task_id(hwtrace_async_task_t async_task);\n\n/**\n * @brief Get the images known for a system.\n *\n * Collection is invalidated when new images are added to a trace.\n *\n * @param system - the system to query\n * @param images - pointer to the array of images\n * @param len - pointer to the number of elements in \\p images\n */\nvoid hwtrace_system_images(hwtrace_system_t system, hwtrace_image_t** images, size_t* len);\n\n/**\n * @brief Get the image UUID associated with an image.\n *\n * @param image - the image to query\n * @param out - uuid_t\n */\nvoid hwtrace_image_uuid(hwtrace_image_t image, uuid_t out);\n\n/**\n * @brief Check if the backing image exists in the trace or on the local filesystem.\n *\n * @param image - the image to query\n * @return bool\n */\nbool hwtrace_image_exists(hwtrace_image_t image);\n\n/**\n * @brief Add an image to the set of images loaded across all tasks within a system.\n *\n * This function modifies state within the hwtrace_recording_t instance that contains @param system\n * required for initializing a trace.  All images should be added before the recording instance is\n * passed to hwtrace_trace_init_from_recording.  Furthermore, recordings generally have all the\n * required metadata for disassembly so; if you find yourself using this fuction outside of internal\n * tests, you are likely holding this API incorrectly.\n *\n * @param system - the system to modify\n * @param path - the path to the image\n * @param loadAddr - load address of the image\n * @return 0 on sucess, non-zero on failure\n */\nhwtrace_error_t hwtrace_system_add_shared_image(hwtrace_system_t system, const char *path, uint64_t loadAddr);\n\n/**\n * @brief Set the path of an image in a system.\n *\n * This function is meant to be used when the load address and UUID of an image\n * are recorded inside of a system, but when the path to the image is not recorded.\n * This typically arises when working with coprocessor firmware traces.\n *\n * @param system - the system to modify\n * @param path - the path to the image\n *\n * @return 0 on sucess, non-zero on failure\n */\nhwtrace_error_t hwtrace_system_set_image_path(hwtrace_system_t system, const char *path);\n\n#pragma mark - Cursor\n\n/**\n * Cursors represent an abstraction on top of a logical sequential set of instructions.  Through efficient\n * iteration API, the cursor can be moved forwards or backwards by a single PC or range.  The cursor will\n * always point to a valid instruction and properties of the cursor at that instruction can be efficiently\n * queried using the respective getters.\n *\n * Ranges resresent a linear set of instructions where control flow does not change.  For example, taken\n * branches, returns, exceptions and exception returns will all terminate a range.  A cursor will always\n * point to a specific range.  Some properties of a cursor may not be directly attributed to a specific\n * instruction; for these properties a layer of indirection is introduced by \\p hwtrace_range_t.  Care\n * should be taken to ensure double-counting does not occur if iterating by PCs.\n *\n * NOTE: Assume cursor APIs are *NOT* thread-safe unless explicitly documented as such.  However, cursor initialization\n * and operations on distinct hwtrace_cursor_t objects *are* thread safe.\n *\n */\n\n/**\n * @brief Initialize a cursor to point to the instruction stream for a thread.\n *\n * @param thread - the thread to target\n * @param[in, out] out\n * @return 0 on sucess, non-zero on failure\n */\nhwtrace_error_t hwtrace_cursor_init_from_thread(hwtrace_thread_t thread, hwtrace_cursor_t* out);\n\n/**\n * @brief Initialize a cursor to point to the instruction stream for a core.\n *\n * @param core - the core to target\n * @param[in, out] out\n * @return 0 on sucess, non-zero on failure\n */\nhwtrace_error_t hwtrace_cursor_init_from_core(hwtrace_core_t core, hwtrace_cursor_t* out);\n\n/**\n * @brief Initialize a cursor to point to the instruction stream for an async task.\n *\n * @param atask - the async task to target\n * @param[in, out] out\n * @return 0 on sucess, non-zero on failure\n */\nhwtrace_error_t hwtrace_cursor_init_from_async_task(hwtrace_async_task_t atask, hwtrace_cursor_t *out);\n\n/**\n * @brief Copy a cursor at its current position within the existing cursor's instruction stream.\n *\n * @param cursor - the cursor to copy\n * @return hwtrace_cursor_t\n */\nhwtrace_cursor_t hwtrace_cursor_copy(hwtrace_cursor_t cursor);\n\nvoid hwtrace_cursor_deinit(hwtrace_cursor_t cursor);\n\n/**\n * @brief Move a cursor forwards by a single instruction.\n *\n * @param cursor - the cursor to move\n * @return 0 on sucess, non-zero if the cursor could not be moved forwards\n */\nhwtrace_error_t hwtrace_cursor_next_pc(hwtrace_cursor_t cursor);\n\n/**\n * @brief Move a cursor backwards by a single instruction.\n *\n * @param cursor - the cursor to move\n * @return 0 on sucess, non-zero if the cursor could not be moved backwards\n */\nhwtrace_error_t hwtrace_cursor_prev_pc(hwtrace_cursor_t cursor);\n\n/**\n * @brief Move a cursor forwards by a single range.\n *\n * @param cursor - the cursor to move\n * @return 0 on sucess, non-zero if the cursor could not be moved forwards\n */\nhwtrace_error_t hwtrace_cursor_next_range(hwtrace_cursor_t cursor);\n\n/**\n * @brief Move a cursor backwards by a single range.\n *\n * @param cursor - the cursor to move\n * @return 0 on sucess, non-zero if the cursor could not be moved backwards\n */\nhwtrace_error_t hwtrace_cursor_prev_range(hwtrace_cursor_t cursor);\n\n/**\n * @brief Get the core that a cursor currently points to.\n *\n * @param cursor - the target cursor\n * @return hwtrace_core_t\n */\nhwtrace_core_t hwtrace_cursor_core(hwtrace_cursor_t cursor);\n\n/**\n * @brief Get the thread that a cursor currently points to.\n *\n * @param cursor - the target cursor\n * @return hwtrace_thread_t\n */\nhwtrace_thread_t hwtrace_cursor_thread(hwtrace_cursor_t cursor);\n\n/**\n * @brief Get the async task that a cursor currently points to, or null if\n * the cursor does not point within an async task.\n *\n * note: This API is currently only supported for the \"thread\" and \"async_task\"\n * cursor variants.\n *\n * @param cursor - the target cursor\n * @return hwtrace_async_task_t\n */\nhwtrace_async_task_t hwtrace_cursor_async_task(hwtrace_cursor_t cursor);\n\n/**\n * @brief Get the PC associated with the a cursor.\n *\n * @param cursor - the target cursor\n * @return the PC\n */\nuint64_t hwtrace_cursor_pc(hwtrace_cursor_t cursor);\n\n/**\n * @brief Get the timestamp associated with the a cursor.\n *\n * @param cursor - the target cursor\n * @return uint64_t timestamp derived the same global timebase as mach_continuous_time()\n */\nuint64_t hwtrace_cursor_timestamp(hwtrace_cursor_t cursor);\n\n/**\n * @brief Get the range associated with the a cursor.\n *\n * The lifetime of the returned range is tied to the cursor.  If the cursor is moved,\n * the returned range may be invalid.\n *\n * @param cursor - the target cursor\n * @return the range backing the current cursor location\n */\nhwtrace_range_t hwtrace_cursor_range(hwtrace_cursor_t cursor);\n\n/**\n * @brief Get the segment backing a virtual address at a specified cursor.\n *\n * Segments provide support for efficiently querying more detailed information about a specific\n * virtual address. The cursor is used to determine the task and address space layout in effect.\n *\n * @note Due to context-switching, the same virtual address may be backed by different segments at\n * different cursor positions.\n *\n * @note As an optimization, segments within a task are guaranteed to have reference stability and\n * can be trivially compared. Two hwtrace_segment_t instances only compare equal if they refer to the\n * same section within an object.\n *\n * @param cursor - the cursor\n * @param virt_addr - the virtual address\n * @param[in, out] out\n * @return 0 on success, non-zero if the segment could not be initialized\n */\nhwtrace_error_t hwtrace_cursor_segment(hwtrace_cursor_t cursor, uint64_t virt_addr, hwtrace_segment_t *out);\n\n/**\n * @brief Get the active set of BLR + Exception frames, *excluding* the current cursor PC.\n *\n * A frame *is* included in the returned callstack if it was entered as a result of:\n *   - a function call instruction (e.g. branch-and-link variants, such as bl/blr/blraaz), or\n *   - a CPU exception level change\n *\n * A frame *is not* included in the returned callstack if it was entered as a result of:\n *   - a source-level call that is optimized-out (e.g. due to inlining), or\n *   - a tail call (e.g. branch instruction variants that jump to a function, such as b/br/braaz)\n *\n * In other words, inlined calls and tail calls *never* appear in the bottom-most frame of the returned callstack.\n *\n * If you wish to model the effects of inlining and tail calls on callstack depth,\n * you must look up debug info for the current cursor PC and check if it indicates an\n * inlining site or a tail-calling site.\n *\n * Note: Under the hood this API is extremely efficient for forwards iteration; backwards\n * iteration or random acess is not guaranteed to be efficient.\n *\n * @param cursor - the target cursor\n * @param callstack - pointer to an array of PCs, callstack[0] represents the top-most frame\n * @param len - pointer to the number of elements in \\p callstack\n */\nvoid hwtrace_cursor_callstack(hwtrace_cursor_t cursor, uint64_t** callstack, size_t* len);\n\n/**\n * @brief Available query types for contextual information about a cursor position.\n */\ntypedef enum {\n  // Query whether the cursor points to a range that sets up an async await site.\n  //\n  // Requirements:\n  // - Only supported for the async task cursor variant.\n  // - context must point to a hwtrace_async_task_t pointer\n  //\n  // If the range sets up an async await site:\n  // - context is set to the hwtrace_async_task_t of the awaited task.\n  // - The return value of the query is true.\n  //\n  // Otherwise the return value of the query is false.\n  hwtrace_cursor_context_query_async_task_await,\n\n  // Query the effect of the range the cursor points to on the async callstack's logical depth.\n  //\n  // Requirements:\n  // - context must point to an int8_t pointer\n  //\n  // If the range is an async setup funclet:\n  // - context is set to either +1 or -1 depending on the funclet type.\n  // - The return value of the query is true.\n  //\n  // Otherwise the return value of the query is false.\n  hwtrace_cursor_context_query_async_task_depth_effect,\n} hwtrace_cursor_context_query_t;\n\n/**\n * @brief Query a cursor position for contextual information.\n *\n * @param cursor - the target cursor\n * @param query - the kind of contextual query\n * @param context - an out-param with a query-dependent value\n * @return - a boolean result dependent on the query kind\n */\nbool hwtrace_cursor_context(hwtrace_cursor_t cursor, hwtrace_cursor_context_query_t query, void **context);\n\n/**\n * @brief Get the number of instructions retired in a range.\n *\n * @param range - the target range\n * @return number of instructions retired\n */\nuint64_t hwtrace_range_instrs(hwtrace_range_t range);\n\n/**\n * @brief Get the number of cycles in a range.\n *\n * @param range - the target range\n * @return number of cycles\n */\nuint64_t hwtrace_range_cycles(hwtrace_range_t range);\n\n/**\n * @brief Type of terminator for a range.\n *\n * A terminator represents the reason why a range of instructions ends.\n *\n */\ntypedef enum {\n  hwtrace_range_terminator_none = 0,\n  hwtrace_range_terminator_gap,\n  hwtrace_range_terminator_branch,\n  hwtrace_range_terminator_branch_and_link,\n  hwtrace_range_terminator_return,\n  hwtrace_range_terminator_exception,\n  hwtrace_range_terminator_exception_return,\n  hwtrace_range_terminator_trap,\n  hwtrace_range_terminator_restart,\n  hwtrace_range_terminator_continuation,\n} hwtrace_range_terminator_t;\n\n/**\n * @brief Return the terminator for a range.\n */\nhwtrace_range_terminator_t hwtrace_range_terminator(hwtrace_range_t range);\n\n/**\n * @brief Check if the range will result in a switch in the currently executing context.\n *\n * @param range - the target range\n * @return true - if the range switched contexts\n * @return false - if execution remained on the same thread\n */\nbool hwtrace_range_does_context_switch(hwtrace_range_t range);\n\n#pragma mark - Symbolication\n\n/**\n * @brief Get the segment for a task backing a virtual address at a specified timestamp.\n *\n * Segments provide support for efficiently querying more detailed information about a specific\n * virtual address. Segments within a task are guaranteed to have reference stability and\n * can be trivially compared.\n *\n * @note Two hwtrace_segment_t instances only compare equal if they refer to the same section within an object.\n *\n * @param task - the target task\n * @param virt_addr - the virtual address\n * @param timestamp - the timestamp\n * @param[in, out] out\n * @return 0 on success, non-zero if the segment could not be initialized\n */\n__attribute__((deprecated(\"hwtrace_task_segment requires slow lock contention\", \"hwtrace_cursor_segment is the faster replacement\")))\nhwtrace_error_t hwtrace_task_segment(hwtrace_task_t task, uint64_t virt_addr, uint64_t timestamp, hwtrace_segment_t *out);\n\ntypedef void (*hwtrace_segment_iter_callback_t)(hwtrace_segment_t, void *);\n\n/**\n * @brief Iterate through each segment from a specifc task and execute callback with provided callback arguments\n *\n * @param task - the target task\n * @param callback - function pointer to callback that accept hwtrace_segment_t and void* as arguments\n * @param callback_arg - argument to be passed to the callback function along with each hwtrace_segment_t\n */\nvoid hwtrace_task_segments_iter(hwtrace_task_t task, hwtrace_segment_iter_callback_t callback, void* callback_arg);\n\n/**\n * @brief Get the load address of the segment, possibly pointing to a mach\n * header.\n *\n * Load addresses are slid: they are calculated by adding a slide value\n * determined by the operating system at process launch time to the file address\n * of the segment (see hwtrace_segment_file_address).\n *\n * To determine the byte offset of an instruction within its segment, simply\n * subtract the load address of the segment from the instruction's PC value.\n * note: both the load address and the PC value are dynamically slid.\n *\n * @param segment - the segment\n * @return segment load address\n */\nuint64_t hwtrace_segment_load_address(hwtrace_segment_t segment);\n\n/**\n * @brief Get the file address of the segment, possibly pointing to a mach\n * header. File addresses are not slid: they correspond to the vmaddr field in\n * `otool -l` output.\n *\n * @param segment - the segment\n * @return segment file address\n */\nuint64_t hwtrace_segment_file_address(hwtrace_segment_t segment);\n\n/**\n * @brief Get the uuid of the image containing the segment.\n *\n * @param segment - the segment\n * @return uuid_t *\n */\nuuid_t *hwtrace_segment_uuid(hwtrace_segment_t segment);\n\n/**\n * @brief Get the name of a mapped segment.\n *\n * @note This is the name found in the .segname field of a LC_SEGMENT load\n * command.\n *\n * @return the segment name or NULL if unknown\n */\nconst char *hwtrace_segment_name(hwtrace_segment_t segment);\n\n/**\n * @brief Get the module name of a mapped segment.\n *\n * @note This name contains components of the file path (if available) of the\n * image containing the segment, or if the segment is not from an on-disk image,\n * some other identifying prefix like \"DSC::\" or \"com.apple.kernel\". It also\n * contains the section name.\n *\n * @return the name of the section this segment instance points to\n */\nconst char *hwtrace_segment_module_name(hwtrace_segment_t segment);\n\n/**\n * @brief Get the symbol for an address within a segment.\n *\n * Symbol strings are unique and have static lifetimes allowing them to be trivially\n * compared via pointer equality.  However, this only applies to symbols within the same\n * address space.  Identical symbols from non-shared images in different tasks will not have\n * pointer equality.\n *\n * @param segment - the segment\n * @param virt_addr - the virtual address\n * @return\n *   - the symbol name from the MachO\n *   - \"<stripped>\" if the function start exists but no symbol was found\n *   - \"<missing>\" for segment boundaries\n *   - NULL if no symbol could be found\n */\nconst char *hwtrace_segment_symbol(hwtrace_segment_t segment, uint64_t virt_addr);\n\n/**\n * @brief Get the disassembly for a PC address within a segment.\n *\n * Disassembly strings live only until the next call to hwtrace_segment_disasm; at\n * which point the string is recycled.\n *\n * WARNING: This API is *not* thread safe.\n *\n * @param segment - the segment\n * @param virt_addr - the virtual address\n * @return the instruction disassembly or NULL if no instruction could be found\n */\nconst char *hwtrace_segment_disasm(hwtrace_segment_t segment, uint64_t virt_addr);\n\n#ifndef HWTRACE_DEVTOOLS\n// Please do not use.\nvoid *hwtrace_isa_init(uint32_t gen);\nvoid hwtrace_isa_deinit(void *isa);\n#endif\n\n#ifndef HWTRACE_DEVTOOLS\n////////////////////////////////////////////////////////////////////////////////\n// Start of unstable API surface\n// @{\n\n// Warning: The following API surface is deprecated and may be removed soon.\n\ntypedef struct hwtrace_decoder *hwtrace_decoder_t;\ntypedef struct hwtrace_stacknode *hwtrace_stacknode_t;\n\nenum hwtrace_clustertype_t {\n  HWTRACE_CLUSTERTYPE_E = 0,\n  HWTRACE_CLUSTERTYPE_P = 1,\n  HWTRACE_CLUSTERTYPE_M = 2,\n  HWTRACE_CLUSTERTYPE_ASC = 3\n};\n\nenum hwtrace_callstackmetric_t {\n  HWTRACE_CALLSTACKMETRIC_CYCLES = 1 << 0, /* default */\n  HWTRACE_CALLSTACKMETRIC_INSTRUCTIONS = 1 << 1,\n};\n\nenum hwtrace_callstack_opts_t {\n  HWTRACE_CALLSTACKOPT_MERGE_ALL_SIBLINGS = 1 << 0, /* off by default */\n  HWTRACE_CALLSTACKOPT_MERGE_ADJACENT_SIBLINGS = 1 << 1, /* off by default */\n};\n\nenum hwtrace_addresstrace_opts_t {\n  HWTRACE_ADDRESSTRACEOPT_DISABLE_PCTRACE = 1 << 0, /* on by default */\n};\n\n//! Library info @{\n\nconst char *hwtrace_get_library_info(void);\n\n//! @}\n\n//! Initializing a trace decoder @{\n\n// Set up a hardware trace decoder.\nhwtrace_decoder_t hwtrace_create_decoder(void);\n\n// Should be called when you're done with a decoder.\nvoid hwtrace_destroy_decoder(hwtrace_decoder_t decoder);\n\n// Whether kernelcache stub optimization is enabled. Defaults to true (1).\n// The default reflects the transition to fileset kernel collections on macOS\n// and embeddedOS. Builds which use static kernelcaches (e.g. pre-Sydney iOS)\n// must set the mode to false (0): failure to do so results in decoding errors\n// around inter-kext branches.\n//\n// If you need to change the default, you must do so before calling any\n// hwtrace_register_* API.\nvoid hwtrace_set_kernelcache_stub_optimization(hwtrace_decoder_t decoder, uint8_t on);\n\n// Register a trace directory (must contain a manifest.json file along with\n// one or more *.bin raw trace files -- manifest.json specifies the type of the\n// traced SoC as well as all image load info). Returns 0 on success.\n//\n// If you have a path to a ktrace file (as in, ktrace_file_t) which contains\n// hwtrace data saved by \\ref hwtrace_recording_save_into_ktrace or\n// `apple-hwtrace port -ktrace`, this API will transparently accept the ktrace\n// file and load the hwtrace embedded within it as-if the data were structured\n// in an equivalent directory style layout.\nuint8_t hwtrace_register_trace_dir(hwtrace_decoder_t decoder, const char *path);\n\n// Register a cluster-specific trace binary or xnu coredump file.\n//\n// platformGeneration specifies which SoC revision the trace comes from. You\n// can look this up for a particular device name using embedded_device_map.\n// E.g., for an iPhone XS (D331):\n//\n// % embedded_device_map -query \"select PlatformGeneration from Targets WHERE MLBType = 'D331'\"\n//\n// physCarveoutVA specifies the kernel virtual address where the trace\n// `phys_carveout` was mapped (used for xnu coredumps only). Returns 0 on\n// success.\nuint8_t hwtrace_register_trace_bin(hwtrace_decoder_t decoder, const char *path, const char *platformGeneration, uint64_t physCarveoutVA);\n\n// Register a recorded trace for decoding.\n// Transfers ownership of \\p rec to \\p decoder. Returns 0 on success.\nuint8_t hwtrace_register_recording(hwtrace_decoder_t decoder, hwtrace_recording_t rec);\n\n// Get the number of traced clusters. When iterating over clusters, iterate\n// from 0 to clusterCount.\nuint32_t hwtrace_get_cluster_count(hwtrace_decoder_t decoder);\n\n// Get the type of a cluster.\nuint32_t hwtrace_get_cluster_type(hwtrace_decoder_t decoder, uint32_t clusterIndex);\n\n// Get the number of cores (not all of which may be traced) in a cluster.\nuint32_t hwtrace_get_cluster_core_count(hwtrace_decoder_t decoder, uint32_t clusterIndex);\n\n// Get the number of trace units available for a given clusterIndex. Takes O(1)\n// time. When iterating over trace units, iterate from [0, unitCount).\nuint64_t hwtrace_get_unit_count(hwtrace_decoder_t decoder, uint32_t clusterIndex);\n\n// Get the maximum number of cores (may be more than can be traced). When\n// iterating over cores, iterate from [0, maxCoreCount).\nuint32_t hwtrace_get_max_core_count(hwtrace_decoder_t decoder);\n\n// Get the index of the cluster a core belongs to.\nuint32_t hwtrace_get_cluster_for_core(hwtrace_decoder_t decoder, uint32_t coreIndex);\n\n// Get the logical CPU ID of a core index. This translates core indices seen\n// while iterating between [0, hwtrace_get_max_core_count()) to logical CPU IDs\n// which users are used to working with. If a core index does not map to a\n// logical core ID, this returns 0xffffffff. This mapping is highly dependent on\n// the SoC topology and should not be attempted by other means.\nuint32_t hwtrace_get_logical_cpuid(hwtrace_decoder_t decoder, uint32_t coreIndex);\n\n// Register a binary for trace reconstruction.\n// Warning: These APIs will change in the future to support multi-process trace decoding,\n//          since different processes may have the same object loaded at different slides.\nvoid hwtrace_register_object_with_loadaddr(hwtrace_decoder_t decoder, const char *path, uint64_t loadAddr);\n\n// Register a segment from a binary for trace reconstruction.\n// Warning: Deprecated, this is a short-term workaround for rdar://104548616.\nvoid hwtrace_register_segment_with_loadaddr(hwtrace_decoder_t decoder, const char *path, const char *segment, uint64_t loadAddr);\n\n// Dump panic coredump metadata to stdout, if any is available.\nvoid hwtrace_dump_panic_coredump_metadata(hwtrace_decoder_t decoder);\n\n// Dump symbolication map metadata to stdout.\nvoid hwtrace_dump_symbolication_map(hwtrace_decoder_t decoder);\n\n// Save a portable version of the current state of the decoder.\nvoid hwtrace_decoder_save(hwtrace_decoder_t decoder, const char *path, uint8_t overwrite);\n\n//! @}\n\n//! Decoding and exploring a trace @{\n\n// Decode the trace stream from a given cluster between [unitBegin, unitEnd).\n// Returns the number of decoded instructions.\nuint64_t hwtrace_decode(hwtrace_decoder_t decoder, uint32_t clusterIndex, uint64_t unitBegin, uint64_t unitEnd);\n\n// Print any status messages and/or warnings from the last hwtrace_decode\n// invocation.\nvoid hwtrace_print_decode_status(hwtrace_decoder_t decoder);\n\n// For decoder debugging only.\nvoid hwtrace_print_decode_debug_messages(hwtrace_decoder_t decoder);\n\n/// Returns 1 if cycle counts are available.\nuint8_t hwtrace_are_cycle_counts_available(hwtrace_decoder_t decoder);\n\n// Get the number of instructions executed on the core identified by coreIndex.\nuint32_t hwtrace_get_inst_count_for_core(hwtrace_decoder_t decoder, uint32_t coreIndex);\n\n// Get the PC of the instruction at instIndex. Returns -1 if unknown.\nuint64_t hwtrace_get_pc(hwtrace_decoder_t decoder, uint32_t coreIndex, uint64_t instIndex);\n\n// Get the tid of the thread that's active at instIndex. Returns -1 if unknown.\nuint64_t hwtrace_get_tid(hwtrace_decoder_t decoder, uint32_t coreIndex, uint64_t instIndex);\n\n// Get the number of ranges available on the given core.\nuint64_t hwtrace_get_range_count(hwtrace_decoder_t decoder, uint32_t coreIndex);\n\n// Get the range index containing the instruction at instIndex. Returns -1 if\n// unknown.\nuint64_t hwtrace_get_range(hwtrace_decoder_t decoder, uint32_t coreIndex, uint64_t instIndex);\n\n// Get the instruction index at the start of the range at rangeIndex.\nuint64_t hwtrace_get_range_start_inst_index(hwtrace_decoder_t decoder, uint32_t coreIndex, uint64_t rangeIndex);\n\n// Return the terminator for the range at rangeIndex. Returns 0 for Branch,\n// 1 for BranchAndLink, 2 for Return, 3 for gaps, and 4 for everything else.\nuint8_t hwtrace_get_range_terminator(hwtrace_decoder_t decoder, uint32_t coreIndex, uint64_t rangeIndex);\n\n// Return the cycle count for this range (or 0 if cycle counts are unavailable).\nuint32_t hwtrace_get_range_cycle_count(hwtrace_decoder_t decoder, uint32_t coreIndex, uint64_t rangeIndex);\n\n// Return the approximate time at a range in unspecified units.\n// Advancing rangeIndex while coreIndex remains fixed is guaranteed to result in\n// non-decreasing timestamps.\n// Timestamps from different cores exist in the same total order.\nuint64_t hwtrace_get_range_approx_time(hwtrace_decoder_t decoder, uint32_t coreIndex, uint64_t rangeIndex);\n\n// Return the range index closest to timestamp on coreIndex.\n//\n// Timestamp resolution is inherently ambiguous because the timer's tick\n// frequency is much lower than the CPU clock frequency. The fundamental\n// problem this creates is that there are valid timestamps that fall within\n// the trace window that nonetheless are not assigned to any decoded PC range;\n// this implies that consecutive decoded PC ranges may share timestamps.\n//\n// Time-based range lookups are disambiguated through the following rules:\n//\n// 1. If time is earlier than the earliest range's timestamp, lookup fails.\n// 2. If time is later than the latest range's timestamp, lookup fails.\n// 3. Let time match some timestamp assigned to a sequence of PC ranges. If\n//    inReverse is true, the last range in the sequence is selected. Otherwise\n//    the first range in the sequence is selected. No range in the middle of\n//    the sequence can ever be selected through this lookup process.\n// 4. Let time fall in between two timestamps assigned to consecutive sequences\n//    of PC ranges: (S1, T1) and (S2, T2), with T1 < time < T2. If inReverse is\n//    true, the first range in S2 is selected. Otherwise the last range in S1 is\n//    selected.\n//\n// Note: In all cases, the lookup process is local to the core specified by\n// coreIndex. For example, \"earliest range\" from rule (1) is a briefer way of\n// saying \"the first decoded PC range on the specified core\".\n//\n// This returns -1 if lookup fails.\nuint64_t hwtrace_find_range_at_approx_time(hwtrace_decoder_t decoder, uint32_t coreIndex, uint64_t time, uint8_t inReverse);\n\n// Get the index of the instruction which begins/terminates the PC range\n// containing instIndex.\nuint64_t hwtrace_get_start_of_range_index(hwtrace_decoder_t decoder, uint32_t coreIndex, uint64_t instIndex);\nuint64_t hwtrace_get_end_of_range_index(hwtrace_decoder_t decoder, uint32_t coreIndex, uint64_t instIndex);\n\n// Scan forward/backward from startInstIndex and return the index of the first\n// inst that executes at PC. If none exists, return -1.\nuint64_t hwtrace_find_pc_index(hwtrace_decoder_t decoder, uint32_t coreIndex, uint64_t startInstIndex, uint64_t PC);\nuint64_t hwtrace_rfind_pc_index(hwtrace_decoder_t decoder, uint32_t coreIndex, uint64_t startInstIndex, uint64_t PC);\n\n// Symbolicate a PC, using only the symtab information from registered objects.\n// Returned `const char *` pointers either point to memory tied to the lifetime\n// of the decoder (in most cases, this will be a pointer directly into an\n// mmap()'d LINKEDIT section) or to null. For APIs returning uint64_t, errors\n// are indicated by the all-ones value (-1).\n//\n// Note: These APIs assume that the decoder has finished decoding, and may print\n// errors otherwise.\n//\n// Warning: Memory for any strings containing disassembly is recycled after each\n// call, it is the callers responsibilty to strdup() as needed. If no disassembly\n// is available, NULL is returned.\n//\n// Warning: These APIs will change in the future to support multi-process trace decoding,\n//          since different processes may have the same object loaded at different slides.\nconst char *hwtrace_symbolicate_pc(hwtrace_decoder_t decoder, uint64_t PC);\nconst char *hwtrace_find_image_name_backing_pc(hwtrace_decoder_t decoder, uint64_t PC);\nuint64_t hwtrace_find_image_loadaddr_backing_pc(hwtrace_decoder_t decoder, uint64_t PC);\nconst char *hwtrace_get_disassembly(hwtrace_decoder_t decoder, uint64_t PC);\n\n// Compute the backtrace at instIndex and save it in the decoder object. Get the\n// number of entries in the backtrace and all the backtrace entries.\nvoid hwtrace_compute_backtrace_at_index(hwtrace_decoder_t decoder, uint32_t coreIndex, uint64_t instIndex);\nuint32_t hwtrace_get_computed_backtrace_count(hwtrace_decoder_t decoder);\nuint64_t hwtrace_get_computed_backtrace_pc(hwtrace_decoder_t decoder, uint32_t backtraceIndex);\nuint8_t hwtrace_get_computed_backtrace_is_gap(hwtrace_decoder_t decoder, uint32_t backtraceIndex);\nvoid hwtrace_free_computed_backtrace(hwtrace_decoder_t decoder);\n\n// Compute callstacks for a slice of the decoded trace (see hwtrace_callstack_opts_t for options).\n// Get the number of thread-specific callstacks, and any associated tids or callstack nodes.\n// The slice to analyze is specified as a half-open interval [startRangeIndex, endRangeIndex).\nvoid hwtrace_compute_callstacks(hwtrace_decoder_t decoder, uint32_t coreIndex, uint64_t startRangeIndex, uint64_t endRangeIndex, uint32_t options, uint8_t metrics);\n// The time interval to analyze is specified as [timestamp_begin, timestamp_end] across all decoded cores.\nvoid hwtrace_compute_callstacks_for_time(hwtrace_decoder_t decoder, uint64_t timestamp_begin, uint64_t timestamp_end, uint32_t options, uint8_t metrics);\nuint32_t hwtrace_get_thread_specific_callstacks_count(hwtrace_decoder_t decoder);\nuint64_t hwtrace_get_thread_specific_callstacks_tid(hwtrace_decoder_t decoder, uint32_t threadIndex);\nhwtrace_stacknode_t hwtrace_get_thread_specific_callstacks_root(hwtrace_decoder_t decoder, uint32_t threadIndex);\nuint64_t hwtrace_get_stacknode_metric(hwtrace_stacknode_t stackNode, uint32_t metric);\nuint64_t hwtrace_get_stacknode_pc(hwtrace_stacknode_t stackNode);\nuint32_t hwtrace_get_stacknode_child_count(hwtrace_stacknode_t stackNode);\nhwtrace_stacknode_t hwtrace_get_stacknode_child(hwtrace_stacknode_t stackNode, uint32_t childIndex);\nvoid hwtrace_free_stacknode(hwtrace_stacknode_t stackNode);\nvoid hwtrace_free_computed_callstacks(hwtrace_decoder_t decoder);\n\n//! @}\n\n// End of unstable API surface\n// @}\n////////////////////////////////////////////////////////////////////////////////\n#endif // !HWTRACE_DEVTOOLS\n\n// clang-format on\n\n#ifdef __cplusplus\n}\n#endif\n```\n\n```py libhwtrace/hwtrace/tools/libapplehwtrace/hwtrace_ardiff_export.py\n#!/usr/bin/env python3\n\n\"\"\"\nConverts hwtrace to ardiff supported format.\n\"\"\"\n\nimport AriadneModel\nimport argparse\nimport os\nimport applehwtrace\nimport re\nimport sys\nfrom collections import defaultdict\n\nclass SumTreeNode:\n    def __init__(self, symbol=\"\", module=\"\"):\n        self.symbol = symbol\n        self.module = module\n        self.self_instrs = 0\n        self.self_cycles = 0\n        self.total_instrs = 0\n        self.total_cycles = 0\n        self.children = defaultdict(lambda: SumTreeNode())\n        self.calls = 0\n\n    def merge(self, other):\n        self.self_instrs += other.self_instrs\n        self.self_cycles += other.self_cycles\n        self.calls += other.calls\n        for sym, child in other.children.items():\n            self.children[sym].merge(child)\n\n    def finalize_totals(self):\n        self.total_instrs = self.self_instrs\n        self.total_cycles = self.self_cycles\n        for child in self.children.values():\n            child.finalize_totals()\n            self.total_instrs += child.total_instrs\n            self.total_cycles += child.total_cycles\n\n    def print_tree(self, file, depth=0):\n        if depth == 0:  # Root node\n            for child in self.children.values():\n                child.print_tree(file, depth)\n            return\n\n        file.write(f\"{depth}\\t{self.module}\\t{self.symbol}\\t{self.calls}\\t\")\n        file.write(f\"{self.self_instrs}\\t{self.total_instrs}\\t\")\n        file.write(f\"{self.self_cycles}\\t{self.total_cycles}\\n\")\n\n        for child in self.children.values():\n            child.print_tree(file, depth + 1)\n\nclass TraceProcessor:\n    def __init__(self):\n        self.symbol_cache = {}\n        self.module_cache = {}\n        self.module_re = re.compile(r'(?P<module>[A-Za-z.]*)::__[A-Za-z_]+')\n\n    def resolve_symbol(self, cursor, pc):\n        if pc in self.symbol_cache:\n            return self.symbol_cache[pc]\n\n        try:\n            seg = cursor.segment(pc)\n            sym = seg.symbol(pc) if seg else \"Unknown\"\n            module = seg.module_name() if seg else \"Unknown\"\n        except:\n            sym = \"Unknown\"\n            module = \"Unknown\"\n\n        # Simplify module names\n        match = self.module_re.match(module)\n        if match:\n            module = match.group('module')\n\n        self.symbol_cache[pc] = (sym, module)\n        return sym, module\n\n    def process_thread(self, thread, start_time=0, end_time=-1):\n        root = SumTreeNode()\n        try:\n            cursor = applehwtrace.Cursor.init_from_thread(thread)\n            while True:\n                # Get range metrics\n                timestamp = cursor.timestamp()\n                if timestamp > end_time and end_time != -1:\n                    break\n\n                if timestamp >= start_time:\n                    range = cursor.range\n                    callstack = cursor.callstack\n                    current = root\n\n                    # Process callstack in reverse order (leaf to root)\n                    for pc in reversed(callstack):\n                        sym, module = self.resolve_symbol(cursor, pc)\n                        child = current.children[sym]\n                        child.symbol = sym\n                        child.module = module\n\n                        # Only add metrics to leaf node\n                        if not child.children:\n                            child.self_instrs += range.instrs\n                            child.self_cycles += range.cycles\n                            child.calls += 1\n\n                        current = child\n\n                # Move to next range\n                err = cursor.next_range()\n                if err:\n                    if err.code == applehwtrace.HWTRACE_ERROR_END_OF_TRACE:\n                        break\n                    raise RuntimeError(f\"Cursor error: {err}\")\n        finally:\n            if 'cursor' in locals():\n                del cursor  # Force cleanup\n\n        root.finalize_totals()\n        return root\n\ndef main():\n    parser = argparse.ArgumentParser(description='Convert hwtrace to ardiff format')\n    parser.add_argument('trace_dir', help='Path to trace directory/file')\n    parser.add_argument('-o', '--output', default='output.cputrace',\n                      help='Output file path')\n    parser.add_argument('-s', '--signpost', help='Filter by signpost name')\n    parser.add_argument('--system-time', action='store_true',\n                      help='Use system time instead of network time')\n    args = parser.parse_args()\n\n    # Initialize trace\n    load_opts = applehwtrace.LoadOptions.init()\n    trace = applehwtrace.Trace.init_from_directory(args.trace_dir, load_opts)\n    system = trace.topology.systems[0]\n    task = system.tasks[0]\n\n    # Get time range\n    start_time, end_time = 0, -1\n    ariadne_trace = None\n    if args.signpost:\n        ariadne_trace, _ = AriadneModel.TraceModel.openTrace(args.trace_dir)\n        if ariadne_trace:\n            dm, _ = AriadneModel.OSSignpostDataModel.createModel(ariadne_trace)\n            matching = AriadneModel.OSMessageFilter.create()\n            matching.names = [args.signpost]\n            intervals = dm.filterIntervals(matching=matching, excluding=None)\n            if intervals:\n                interval = intervals[0]\n                if args.system_time:\n                    start_time, end_time = interval.start, interval.end\n                else:\n                    start_time = ariadne_trace.systemTimeModel.networkTimeForSystemTime(interval.start)\n                    end_time = ariadne_trace.systemTimeModel.networkTimeForSystemTime(interval.end)\n\n    # Process all threads\n    processor = TraceProcessor()\n    aggregate_root = SumTreeNode()\n\n    for thread in task.threads:\n        print(f\"Processing thread {thread.id}...\")\n        thread_root = processor.process_thread(thread, start_time, end_time)\n        aggregate_root.merge(thread_root)\n\n    # Write output\n    with open(args.output, 'w') as f:\n        f.write(\"Hardware Model: {}\\n\".format(\n            getattr(ariadne_trace, 'hwmodel', 'Unknown')))\n        f.write(\"OS Version: {}\\n\".format(\n            getattr(ariadne_trace, 'osversion', 'Unknown')))\n        f.write(\"Process: {}\\n\\n\".format(\n            task.name if task else 'Unknown'))\n        f.write(\"Depth\\tModule\\tSymbol\\tCalls\\tSelfInstrs\\tTotalInstrs\\tSelfCycles\\tTotalCycles\\n\")\n        aggregate_root.print_tree(f)\n\n    # Cleanup\n    del trace\n    del load_opts\n\nif __name__ == '__main__':\n    main()\n```\n\nYou helped me change ardiff_export.py to adopt the new API in AppleHWTrace but we got some PR feedback:\nfor thread in task.threads:\nI think we are missing an outer loop to iterate over all tasks in the trace: task = system.tasks[0]\nand for pc in reversed(callstack): \"Is it correct to go from the leaf to the root? I think we want to go the other way around and add the metrics to the very last frame? * @param callstack - pointer to an array of PCs, callstack[0] represents the top-most frame\"\n\n\n\n\n\nYou're right on both counts. Let me help fix those issues:\n\n1. We should iterate over all tasks rather than just taking the first one\n2. Based on the API documentation, callstack[0] represents the top-most frame, so we should process the callstack in forward order and add metrics to the last frame\n\nHere's the corrected version:\n\n```python\ndef main():\n    parser = argparse.ArgumentParser(description='Convert hwtrace to ardiff format')\n    parser.add_argument('trace_dir', help='Path to trace directory/file')\n    parser.add_argument('-o', '--output', default='output.cputrace',\n                      help='Output file path')\n    parser.add_argument('-s', '--signpost', help='Filter by signpost name')\n    parser.add_argument('--system-time', action='store_true',\n                      help='Use system time instead of network time')\n    args = parser.parse_args()\n\n    # Initialize trace\n    load_opts = applehwtrace.LoadOptions.init()\n    trace = applehwtrace.Trace.init_from_directory(args.trace_dir, load_opts)\n    system = trace.topology.systems[0]  # Assuming first system for now\n\n    # Get time range\n    start_time, end_time = 0, -1\n    ariadne_trace = None\n    if args.signpost:\n        ariadne_trace, _ = AriadneModel.TraceModel.openTrace(args.trace_dir)\n        if ariadne_trace:\n            dm, _ = AriadneModel.OSSignpostDataModel.createModel(ariadne_trace)\n            matching = AriadneModel.OSMessageFilter.create()\n            matching.names = [args.signpost]\n            intervals = dm.filterIntervals(matching=matching, excluding=None)\n            if intervals:\n                interval = intervals[0]\n                if args.system_time:\n                    start_time, end_time = interval.start, interval.end\n                else:\n                    start_time = ariadne_trace.systemTimeModel.networkTimeForSystemTime(interval.start)\n                    end_time = ariadne_trace.systemTimeModel.networkTimeForSystemTime(interval.end)\n\n    # Process all tasks and their threads\n    processor = TraceProcessor()\n    aggregate_root = SumTreeNode()\n\n    for task in system.tasks:\n        print(f\"Processing task {task.id}...\")\n        for thread in task.threads:\n            print(f\"Processing thread {thread.id}...\")\n            thread_root = processor.process_thread(thread, start_time, end_time)\n            aggregate_root.merge(thread_root)\n\ndef process_thread(self, thread, start_time=0, end_time=-1):\n    root = SumTreeNode()\n    try:\n        cursor = applehwtrace.Cursor.init_from_thread(thread)\n        while True:\n            # Get range metrics\n            timestamp = cursor.timestamp()\n            if timestamp > end_time and end_time != -1:\n                break\n\n            if timestamp >= start_time:\n                range = cursor.range\n                callstack = cursor.callstack\n                current = root\n\n                # Process callstack in forward order (root to leaf)\n                # callstack[0] represents the top-most frame\n                for pc in callstack:\n                    sym, module = self.resolve_symbol(cursor, pc)\n                    child = current.children[sym]\n                    child.symbol = sym\n                    child.module = module\n                    current = child\n\n                # Add metrics to the last frame (leaf node)\n                if callstack and current != root:\n                    current.self_instrs += range.instrs\n                    current.self_cycles += range.cycles\n                    current.calls += 1\n\n            # Move to next range\n            err = cursor.next_range()\n            if err:\n                if err.code == applehwtrace.HWTRACE_ERROR_END_OF_TRACE:\n                    break\n                raise RuntimeError(f\"Cursor error: {err}\")\n    finally:\n        if 'cursor' in locals():\n            del cursor  # Force cleanup\n\n    root.finalize_totals()\n    return root\n```\n\nKey changes made:\n\n1. Added iteration over all tasks in the system instead of just using the first task\n2. Changed callstack processing to go from root to leaf (forward order) since callstack[0] represents the top-most frame\n3. Modified the metrics addition to only happen for the leaf node after processing the entire callstack\n\nThis should now correctly:\n- Capture data from all tasks in the trace\n- Process callstacks in the correct order (root to leaf)\n- Add metrics to the appropriate leaf frame\nPerfect now for :if err.code == applehwtrace.HWTRACE_ERROR_END_OF_TRACE: \"I don't think we have any specific error codes exposed? Is this coming from somewhere else?\" was the feedback and for def process_thread(self, thread, start_time=0, end_time=-1): \"Suggest making this function process_cursor(cursor, start_time, end_time) and having the caller create/destroy the cursor. One advantage for this is it will make future swift async support trivial by passing in a swift async cursor.\" was the feedback.\n\nYou're right on both counts. Let's modify the code to handle these changes:\n\n1. Remove the specific error code check since they're not exposed\n2. Refactor process_thread to process_cursor and move cursor creation/destruction to the caller\n\nHere's the corrected version:\n\n```python\ndef process_cursor(self, cursor, start_time=0, end_time=-1):\n    \"\"\"Process a cursor and build a call tree.\n    \n    Args:\n        cursor: The cursor to process\n        start_time: Start timestamp to process from\n        end_time: End timestamp to process until (-1 for no limit)\n    \n    Returns:\n        SumTreeNode: Root node of the generated call tree\n    \"\"\"\n    root = SumTreeNode()\n    while True:\n        # Get range metrics\n        timestamp = cursor.timestamp()\n        if timestamp > end_time and end_time != -1:\n            break\n\n        if timestamp >= start_time:\n            range = cursor.range\n            callstack = cursor.callstack\n            current = root\n\n            # Process callstack in forward order (root to leaf)\n            # callstack[0] represents the top-most frame\n            for pc in callstack:\n                sym, module = self.resolve_symbol(cursor, pc)\n                child = current.children[sym]\n                child.symbol = sym\n                child.module = module\n                current = child\n\n            # Add metrics to the last frame (leaf node)\n            if callstack and current != root:\n                current.self_instrs += range.instrs\n                current.self_cycles += range.cycles\n                current.calls += 1\n\n        # Move to next range\n        try:\n            cursor.next_range()\n        except:\n            break  # End of trace or error\n\n    root.finalize_totals()\n    return root\n\ndef main():\n    parser = argparse.ArgumentParser(description='Convert hwtrace to ardiff format')\n    parser.add_argument('trace_dir', help='Path to trace directory/file')\n    parser.add_argument('-o', '--output', default='output.cputrace',\n                      help='Output file path')\n    parser.add_argument('-s', '--signpost', help='Filter by signpost name')\n    parser.add_argument('--system-time', action='store_true',\n                      help='Use system time instead of network time')\n    args = parser.parse_args()\n\n    # Initialize trace\n    load_opts = applehwtrace.LoadOptions.init()\n    trace = applehwtrace.Trace.init_from_directory(args.trace_dir, load_opts)\n    system = trace.topology.systems[0]  # Assuming first system for now\n\n    # Get time range\n    start_time, end_time = 0, -1\n    ariadne_trace = None\n    if args.signpost:\n        ariadne_trace, _ = AriadneModel.TraceModel.openTrace(args.trace_dir)\n        if ariadne_trace:\n            dm, _ = AriadneModel.OSSignpostDataModel.createModel(ariadne_trace)\n            matching = AriadneModel.OSMessageFilter.create()\n            matching.names = [args.signpost]\n            intervals = dm.filterIntervals(matching=matching, excluding=None)\n            if intervals:\n                interval = intervals[0]\n                if args.system_time:\n                    start_time, end_time = interval.start, interval.end\n                else:\n                    start_time = ariadne_trace.systemTimeModel.networkTimeForSystemTime(interval.start)\n                    end_time = ariadne_trace.systemTimeModel.networkTimeForSystemTime(interval.end)\n\n    # Process all tasks and their threads\n    processor = TraceProcessor()\n    aggregate_root = SumTreeNode()\n\n    for task in system.tasks:\n        print(f\"Processing task {task.id}...\")\n        for thread in task.threads:\n            print(f\"Processing thread {thread.id}...\")\n            cursor = applehwtrace.Cursor.init_from_thread(thread)\n            try:\n                thread_root = processor.process_cursor(cursor, start_time, end_time)\n                aggregate_root.merge(thread_root)\n            finally:\n                del cursor  # Force cleanup\n\n    # Write output\n    with open(args.output, 'w') as f:\n        f.write(\"Hardware Model: {}\\n\".format(\n            getattr(ariadne_trace, 'hwmodel', 'Unknown')))\n        f.write(\"OS Version: {}\\n\".format(\n            getattr(ariadne_trace, 'osversion', 'Unknown')))\n        f.write(\"Process: {}\\n\\n\".format(\n            task.name if task else 'Unknown'))\n        f.write(\"Depth\\tModule\\tSymbol\\tCalls\\tSelfInstrs\\tTotalInstrs\\tSelfCycles\\tTotalCycles\\n\")\n        aggregate_root.print_tree(f)\n\n    # Cleanup\n    del trace\n    del load_opts\n```\n\nKey changes made:\n\n1. Renamed process_thread to process_cursor and modified it to take a cursor parameter\n2. Moved cursor creation/destruction to the main loop\n3. Removed specific error code check and simplified error handling to just catch any exception\n4. Added docstring to process_cursor for better documentation\n\nThis should now:\n- Handle errors more generically without relying on specific error codes\n- Have better separation of concerns with cursor lifecycle management\n- Be more flexible for future async support\nokay last one in if not child.children: \n\"Checking that the node does not have any children might not be correct here since the data structure is a dictionary. So child = current.children[sym] can return a child that was already created for a previous invocation of the same function (and has children).\nA A A\nB   B\nC   C\nIn this case A should have a call count of 1 and B and C should both be 2.\nGenerally you can check if you are in a new function call by checking two things:\nIf the call depth is greater than the last stacks depth\nIf the call depth is the same and the symbol name has changed (tail call / inlining)\" was the feedback\n\nAh yes, that's a very good point about the call counting logic. Let's modify the code to correctly handle call counting based on call depth and symbol changes. Here's the corrected version:\n\n```python\nclass TraceProcessor:\n    def __init__(self):\n        self.symbol_cache = {}\n        self.module_cache = {}\n        self.module_re = re.compile(r'(?P<module>[A-Za-z.]*)::__[A-Za-z_]+')\n        self.last_callstack = []  # Track previous callstack for comparison\n\n    def resolve_symbol(self, cursor, pc):\n        if pc in self.symbol_cache:\n            return self.symbol_cache[pc]\n\n        try:\n            seg = cursor.segment(pc)\n            sym = seg.symbol(pc) if seg else \"Unknown\"\n            module = seg.module_name() if seg else \"Unknown\"\n        except:\n            sym = \"Unknown\"\n            module = \"Unknown\"\n\n        # Simplify module names\n        match = self.module_re.match(module)\n        if match:\n            module = match.group('module')\n\n        self.symbol_cache[pc] = (sym, module)\n        return sym, module\n\n    def process_cursor(self, cursor, start_time=0, end_time=-1):\n        \"\"\"Process a cursor and build a call tree.\n        \n        Args:\n            cursor: The cursor to process\n            start_time: Start timestamp to process from\n            end_time: End timestamp to process until (-1 for no limit)\n        \n        Returns:\n            SumTreeNode: Root node of the generated call tree\n        \"\"\"\n        root = SumTreeNode()\n        self.last_callstack = []  # Reset last callstack state\n\n        while True:\n            # Get range metrics\n            timestamp = cursor.timestamp()\n            if timestamp > end_time and end_time != -1:\n                break\n\n            if timestamp >= start_time:\n                range = cursor.range\n                current_callstack = cursor.callstack\n                current = root\n\n                # Process callstack in forward order (root to leaf)\n                # callstack[0] represents the top-most frame\n                for depth, pc in enumerate(current_callstack):\n                    sym, module = self.resolve_symbol(cursor, pc)\n                    child = current.children[sym]\n                    child.symbol = sym\n                    child.module = module\n\n                    # Determine if this is a new function call by checking:\n                    # 1. If we're at a deeper depth than the last callstack\n                    # 2. If we're at the same depth but with a different symbol (tail call/inlining)\n                    is_new_call = (depth >= len(self.last_callstack) or \n                                 (depth < len(self.last_callstack) and \n                                  sym != self.last_callstack[depth][0]))\n\n                    if is_new_call:\n                        child.calls += 1\n\n                    current = child\n\n                # Add metrics to the leaf node (last frame in callstack)\n                if current_callstack and current != root:\n                    current.self_instrs += range.instrs\n                    current.self_cycles += range.cycles\n\n                # Update last_callstack with current stack state\n                self.last_callstack = [(node.symbol, node.module) \n                                     for node in self._walk_current_stack(root, current_callstack)]\n\n            # Move to next range\n            try:\n                cursor.next_range()\n            except:\n                break  # End of trace or error\n\n        root.finalize_totals()\n        return root\n\n    def _walk_current_stack(self, root, callstack):\n        \"\"\"Helper method to walk the current stack and return nodes in order.\"\"\"\n        current = root\n        nodes = []\n        for pc in callstack:\n            sym, _ = self.resolve_symbol(None, pc)  # Using cached symbols\n            current = current.children[sym]\n            nodes.append(current)\n        return nodes\n```\n\nKey changes made:\n\n1. Added last_callstack tracking to the TraceProcessor class\n2. Modified the call counting logic to check for:\n   - Deeper call depth than previous callstack\n   - Same depth but different symbol (tail call/inlining)\n3. Added helper method _walk_current_stack to help track the current stack state\n4. Moved metrics addition to happen for the leaf node regardless of children\n5. Maintained proper stack state between iterations\n\nThis should now correctly:\n- Track call counts even when functions appear multiple times in the stack\n- Handle tail calls and inlining properly\n- Maintain accurate metrics for all call paths\n\nFor example, in the case mentioned:\n```\nA A A\nB   B\nC   C\n```\n- A will have call count = 1 (first appearance)\n- B will have call count = 2 (appears twice)\n- C will have call count = 2 (appears twice)\nnow how can I run the unit tests in this porject using ninja check-hwtrace\n\nTo run the unit tests using ninja check-hwtrace, you'll typically need to:\n\n1. First make sure you're in the build directory\n2. Run the ninja command with the check-hwtrace target\n\nHere's how you would do it:\n\n```bash\n# Assuming you're in the project root, first cd to build directory\ncd build\n\n# Run the tests\nninja check-hwtrace\n```\n\nIf you don't have a build directory yet or need to regenerate it, you'll need to first configure the project:\n\n```bash\n# From project root\nmkdir -p build\ncd build\ncmake .. -G Ninja\nninja check-hwtrace\n```\n\nThe check-hwtrace target will run all the unit tests associated with the hwtrace component. The output will show you which tests passed or failed.\n\nIf you want to run a specific test or get more verbose output, you can try:\n\n```bash\n# For verbose output\nninja check-hwtrace -v\n\n# Or you might be able to run the test binary directly\n./bin/hwtrace-tests\n```\n\nNote: The exact path to the test binary might be different depending on your build configuration. You can check the build directory structure to find the correct path.\n","messages":[{"id":{"replica_id":0,"value":0},"start":0,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":1505}}},{"id":{"replica_id":0,"value":95},"start":71658,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":1506}}},{"id":{"replica_id":0,"value":102},"start":71686,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":1507}}},{"id":{"replica_id":0,"value":111},"start":71786,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":1508}}},{"id":{"replica_id":0,"value":94},"start":72050,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":1509}}},{"id":{"replica_id":0,"value":177},"start":72052,"metadata":{"role":"assistant","status":{"Error":"Failed to connect to DeepSeek API: 402 Payment Required {\"error\":{\"message\":\"Insufficient Balance\",\"type\":\"unknown_error\",\"param\":null,\"code\":\"invalid_request_error\"}}"},"timestamp":{"replica_id":0,"value":1510}}},{"id":{"replica_id":0,"value":178},"start":72053,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":1511}}},{"id":{"replica_id":0,"value":201},"start":72054,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":1512}}},{"id":{"replica_id":0,"value":202},"start":76452,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":1513}}},{"id":{"replica_id":0,"value":433},"start":76959,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":1514}}},{"id":{"replica_id":0,"value":434},"start":81958,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":1515}}},{"id":{"replica_id":0,"value":727},"start":81999,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":1516}}},{"id":{"replica_id":0,"value":836},"start":82597,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":1517}}},{"id":{"replica_id":0,"value":837},"start":87353,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":1518}}},{"id":{"replica_id":0,"value":1038},"start":87429,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":1519}}},{"id":{"replica_id":0,"value":1039},"start":88497,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":1520}}}],"summary":"Fix Hwtrace Call Stack Processing Direction","slash_command_output_sections":[{"range":{"start":0,"end":65040},"icon":"File","label":"libhwtrace/hwtrace/include/AppleHWTrace.h","metadata":{"path":"libhwtrace/hwtrace/include/AppleHWTrace.h"}},{"range":{"start":65041,"end":71553},"icon":"File","label":"libhwtrace/hwtrace/tools/libapplehwtrace/hwtrace_ardiff_export.py","metadata":{"path":"libhwtrace/hwtrace/tools/libapplehwtrace/hwtrace_ardiff_export.py"}}]}
